// Generated by CoffeeScript 2.4.1
(function() {
  // Response and associated API
  // ===========================
  var EventEmitter2, FreeSwitchError, FreeSwitchResponse, FreeSwitchTimeout, UUID, assert, async_log, debug, ref, trace;

  ({EventEmitter2} = require('eventemitter2'));

  UUID = require('uuid');

  async_log = function(msg, af) {
    return function() {
      return af().catch(function(error) {
        debug(msg, error);
        return Promise.reject(error);
      });
    };
  };

  FreeSwitchError = class FreeSwitchError extends Error {
    constructor(res, args) {
      super();
      this.res = res;
      this.args = args;
      return;
    }

    toString() {
      return `FreeSwitchError: ${JSON.stringify(this.args)}`;
    }

  };

  FreeSwitchTimeout = class FreeSwitchTimeout extends Error {
    constructor(timeout, text) {
      super();
      this.timeout = timeout;
      this.text = text;
      return;
    }

    toString() {
      return `FreeSwitchTimeout: Timeout after ${this.timeout}ms waiting for ${this.text}`;
    }

  };

  // Uniquely identify each instance, for tracing purposes.
  ref = 0;

  module.exports = FreeSwitchResponse = (function() {
    class FreeSwitchResponse extends EventEmitter2 {
      // The `FreeSwitchResponse` is bound to a single socket (dual-stream). For outbound (server) mode this would represent a single socket call from FreeSwitch.
      constructor(socket) {
        var once_socket_star, socket_on_error, socket_once_close;
        assert(socket != null, 'Missing socket parameter');
        super({
          wildcard: true,
          verboseMemoryLeak: true
        });
        this.__ref = (ref = (ref + 1) % 1000000000);
        this.socket = socket;
        // The object also provides a queue for operations which need to be submitted one after another on a given socket because FreeSwitch does not provide ways to map event socket requests and responses in the general case.
        this.__queue = Promise.resolve(null);
        // The object also provides a mechanism to report events that might already have been triggered.
        this.__later = new Map;
        // We also must track connection close in order to prevent writing to a closed socket.
        this.closed = false;
        this.socket.once('close', socket_once_close = () => {
          debug('Socket closed', this.__ref);
          this.emit('socket.close');
        });
        // Default handler for `error` events to prevent `Unhandled 'error' event` reports.
        this.socket.once('error', socket_on_error = (err) => {
          debug('Socket Error', this.__ref, err);
          this.emit('socket.error', err);
        });
        // After the socket is closed or errored, this object is no longer usable.
        this.once('socket.*', once_socket_star = () => {
          debug('Terminate', this.__ref);
          this.closed = true;
          this.removeAllListeners();
          this.__queue = null;
          this.__later = null;
          this.socket.end();
          this.socket = null;
        });
        null;
      }

      error(res, data) {
        debug("error: new FreeSwitchError", this.__ref, {res, data});
        return Promise.reject(new FreeSwitchError(res, data));
      }

      
      // Most commands allow you to specify a timeout.

      // onceAsync
      // ---------
      onceAsync(event, timeout, comment) {
        var onceAsyncHandler;
        trace('onceAsync', this.__ref, event, timeout);
        onceAsyncHandler = (resolve, reject) => {
          var cleanup, on_error, on_event, on_timeout, timer;
          on_event = function(...args) {
            trace(`onceAsync: on_event ${event} in ${comment}`, this.__ref, args);
            cleanup();
            resolve(...args);
          };
          on_error = function(error) {
            trace(`onceAsync: on_error ${event}`, this.__ref, error);
            cleanup();
            reject(error != null ? error : new Error(`Socket closed (${this.__ref}) while waiting for ${event} in ${comment}`));
          };
          on_timeout = function() {
            trace(`onceAsync: on_timeout ${event}`, this.__ref);
            cleanup();
            reject(new FreeSwitchTimeout(timeout, `(${this.__ref}) event ${event} in ${comment}`));
          };
          cleanup = () => {
            this.removeListener(event, on_event);
            this.removeListener('socket.*', on_error);
            clearTimeout(timer);
          };
          this.once(event, on_event);
          this.once('socket.*', on_error);
          if (timeout != null) {
            timer = setTimeout(on_timeout, timeout);
          }
        };
        return new Promise(onceAsyncHandler);
      }

      // Queueing
      // ========

      // Enqueue a function that returns a Promise.
      // The function is only called when all previously enqueued functions-that-return-Promises are completed and their respective Promises fulfilled or rejected.
      enqueue(f) {
        var next, q;
        if (this.__queue == null) {
          return this.error({}, {
            when: 'enqueue on closed socket'
          });
        }
        q = this.__queue;
        next = (async function() {
          await q;
          return (await f());
        })();
        this.__queue = next.catch(function() {
          return true;
        });
        return next;
      }

      // Sync/Async event
      // ================

      // waitAsync
      // ---------

      // In some cases the event might have been emitted before we are ready to receive it.
      // In that case we store the data in `@__later` so that we can emit the event when the recipient is ready.
      waitAsync(event, timeout, comment) {
        var v;
        if ((this.__later != null) && this.__later.has(event)) {
          v = this.__later.get(event);
          this.__later.delete(event);
          return Promise.resolve(v);
        } else {
          return this.onceAsync(event, timeout, `waitAsync ${comment}`);
        }
      }

      // emit_later
      // ----------

      // This is used for events that might trigger before we set the `once` receiver.
      emit_later(event, data) {
        var handled;
        handled = this.emit(event, data);
        if ((this.__later != null) && !handled) {
          this.__later.set(event, data);
        }
        return handled;
      }

      // Low-level sending
      // =================

      // These methods are normally not used directly.

      // write
      // -----

      // Send a single command to FreeSwitch; `args` is a hash of headers sent with the command.
      write(command, args) {
        var writeHandler;
        if (this.closed) {
          return this.error({}, {
            when: 'write on closed socket',
            command,
            args
          });
        }
        writeHandler = (resolve, reject) => {
          var error, key, text, value;
          try {
            trace('write', this.__ref, {command, args});
            text = `${command}\n`;
            if (args != null) {
              for (key in args) {
                value = args[key];
                text += `${key}: ${value}\n`;
              }
            }
            text += "\n";
            this.socket.write(text, 'utf8');
            resolve(null);
          } catch (error1) {
            error = error1;
            // Cancel any pending Promise started with `@onceAsync`, and close the connection.
            this.emit('socket.write', error);
            reject(error);
          }
        };
        return new Promise(writeHandler);
      }

      // send
      // ----

      // A generic way of sending commands to FreeSwitch, wrapping `write` into a Promise that waits for FreeSwitch's notification that the command completed.
      async send(command, args, timeout = this.command_timeout) {
        var msg, sendHandler;
        if (this.closed) {
          return this.error({}, {
            when: 'send on closed socket',
            command,
            args
          });
        }
        // Typically `command/reply` will contain the status in the `Reply-Text` header while `api/response` will contain the status in the body.
        msg = `send ${command} ${JSON.stringify(args)}`;
        sendHandler = async() => {
          var p, q, reply, res;
          p = this.onceAsync('freeswitch_command_reply', timeout, msg);
          q = this.write(command, args);
          [res] = (await Promise.all([p, q]));
          trace('send: received reply', this.__ref, {command, args});
          reply = res != null ? res.headers['Reply-Text'] : void 0;
          // The Promise might fail if FreeSwitch's notification indicates an error.
          if (reply == null) {
            trace('send: no reply', this.__ref, {command, args});
            return this.error(res, {
              when: 'no reply to command',
              command,
              args
            });
          }
          if (reply.match(/^-/)) {
            debug('send: failed', this.__ref, reply, {command, args});
            return this.error(res, {
              when: 'command reply',
              reply,
              command,
              args
            });
          }
          // The promise will be fulfilled with the `{headers,body}` object provided by the parser.
          trace('send: success', this.__ref, {command, args});
          return res;
        };
        return (await this.enqueue(async_log(msg, sendHandler)));
      }

      // end
      // ---

      // Closes the socket.
      end() {
        trace('end', this.__ref);
        try {
          this.emit('socket.end');
        } catch (error1) {}
      }

      // Channel-level commands
      // ======================

      // api
      // ---

      // Send an API command, see [Mod commands](http://wiki.freeswitch.org/wiki/Mod_commands) for a list.
      // Returns a Promise that is fulfilled as soon as FreeSwitch sends a reply. Requests are queued and each request is matched with the first-coming response, since there is no way to match between requests and responses.
      // Use `bgapi` if you need to make sure responses are correct, since it provides the proper semantices.
      async api(command, timeout) {
        var apiHandler, msg;
        trace('api', this.__ref, {command});
        if (this.closed) {
          return this.error({}, {
            when: 'api on closed socket',
            command
          });
        }
        msg = `api ${command}`;
        apiHandler = async() => {
          var p, q, ref1, reply, res;
          p = this.onceAsync('freeswitch_api_response', timeout, msg);
          q = this.write(`api ${command}`);
          [res] = (await Promise.all([p, q]));
          trace('api: response', this.__ref, {command});
          reply = res != null ? res.body : void 0;
          // The Promise might fail if FreeSwitch indicates there was an error.
          if (reply == null) {
            debug('api: no reply', this.__ref, {command});
            return this.error(res, {
              when: 'no reply to api',
              command
            });
          }
          if (reply.match(/^-/)) {
            debug('api response failed', this.__ref, {reply, command});
            return this.error(res, {
              when: 'api response',
              reply,
              command
            });
          }
          // The Promise that will be fulfilled with `{headers,body,uuid}` from the parser; uuid is the API UUID if one is provided by FreeSwitch.
          res.uuid = (ref1 = reply.match(/^\+OK ([\da-f-]{36})/)) != null ? ref1[1] : void 0;
          return res;
        };
        return (await this.enqueue(async_log(msg, apiHandler)));
      }

      // bgapi
      // -----

      // Send an API command in the background. Wraps it inside a Promise.
      async bgapi(command, timeout) {
        var error, r, ref1, reply, res;
        trace('bgapi', this.__ref, {command, timeout});
        if (this.closed) {
          return this.error({}, {
            when: 'bgapi on closed socket',
            command
          });
        }
        res = (await this.send(`bgapi ${command}`));
        error = () => {
          return this.error(res, {
            when: "bgapi did not provide a Job-UUID",
            command
          });
        };
        if (res == null) {
          return error();
        }
        reply = res.headers['Reply-Text'];
        r = reply != null ? (ref1 = reply.match(/\+OK Job-UUID: (.+)$/)) != null ? ref1[1] : void 0 : void 0;
        if (r == null) {
          r = res.headers['Job-UUID'];
        }
        if (r == null) {
          return error();
        }
        trace('bgapi retrieve', this.__ref, r);
        return (await this.waitAsync(`BACKGROUND_JOB ${r}`, timeout, `bgapi ${command}`));
      }

      // Event reception and filtering
      // =============================

      // event_json
      // ----------

      // Request that the server send us events in JSON format.
      // For example: `res.event_json 'HEARTBEAT'`
      event_json(...events) {
        return this.send(`event json ${events.join(' ')}`);
      }

      // nixevents
      // ---------

      // Remove the given event types from the events ACL.
      nixevent(...events) {
        return this.send(`nixevent ${events.join(' ')}`);
      }

      // noevents
      // --------

      // Remove all events types.
      noevents() {
        return this.send("noevents");
      }

      // filter
      // ------

      // Generic event filtering
      filter(header, value) {
        return this.send(`filter ${header} ${value}`);
      }

      // filter_delete
      // -------------

      // Remove a filter.
      filter_delete(header, value) {
        if (value != null) {
          return this.send(`filter delete ${header} ${value}`);
        } else {
          return this.send(`filter delete ${header}`);
        }
      }

      // sendevent
      // ---------

      // Send an event into the FreeSwitch event queue.
      sendevent(event_name, args) {
        return this.send(`sendevent ${event_name}`, args);
      }

      // Connection handling
      // ===================

      // auth
      // ----

      // Authenticate with FreeSwitch.

      // This normally not needed since in outbound (server) mode authentication is not required, and for inbound (client) mode the module authenticates automatically when requested.
      auth(password) {
        return this.send(`auth ${password}`);
      }

      // connect
      // -------

      // Used in server mode to start the conversation with FreeSwitch.

      // Normally not needed, triggered automatically by the module.
      connect() {
        return this.send("connect"); // Outbound mode
      }

      
      // linger
      // ------

      // Used in server mode, requests FreeSwitch to not close the socket as soon as the call is over, allowing us to do some post-processing on the call (mainly, receiving call termination events).
      // By default, `esl` with call `exit()` for you after 4 seconds. You need to capture the `cleanup_linger` event if you want to handle things differently.
      linger() {
        return this.send("linger"); // Outbound mode
      }

      
      // exit
      // ----

      // Send the `exit` command to the FreeSwitch socket.
      // FreeSwitch will respond with "+OK bye" followed by a `disconnect-notice` message, which gets translated into a `freeswitch_disconnect_notice` event internally, which in turn gets translated into either `freeswitch_disconnect` or `freeswitch_linger` depending on whether `linger` was called on the socket.
      // You normally do not need to call `@exit` directly. If you do, make sure you do handle any rejection.
      exit() {
        return this.send("exit");
      }

      // Event logging
      // =============

      // log
      // ---

      // Enable logging on the socket, optionnally setting the log level.
      log(level) {
        if (level != null) {
          return this.send(`log ${level}`);
        } else {
          return this.send("log");
        }
      }

      // nolog
      // -----

      // Disable logging on the socket.
      nolog() {
        return this.send("nolog");
      }

      // Message sending
      // ===============

      // sendmsg_uuid
      // ------------

      // Send a command to a given UUID.
      sendmsg_uuid(uuid, command, args) {
        var execute_text, options;
        options = args != null ? args : {};
        options['call-command'] = command;
        execute_text = uuid != null ? `sendmsg ${uuid}` : 'sendmsg';
        return this.send(execute_text, options);
      }

      // sendmsg
      // -------

      // Send Message, assuming server/outbound ESL mode (in which case the UUID is not required).
      sendmsg(command, args) {
        return this.sendmsg_uuid(null, command, args);
      }

      // Client-mode ("inbound") commands
      // =================================

      // The target UUID must be specified.

      // execute_uuid
      // ------------

      // Execute an application for the given UUID (in client mode).
      execute_uuid(uuid, app_name, app_arg, loops, event_uuid) {
        var options;
        options = {
          'execute-app-name': app_name,
          'execute-app-arg': app_arg
        };
        if (loops != null) {
          options.loops = loops;
        }
        if (event_uuid != null) {
          options['Event-UUID'] = event_uuid;
        }
        return this.sendmsg_uuid(uuid, 'execute', options);
      }

      // TODO: Support the alternate format (with no `execute-app-arg` header but instead a `text/plain` body containing the argument).

      // command_uuid
      // ------------

      // Execute an application synchronously. Return a Promise.
      async command_uuid(uuid, app_name, app_arg, timeout = this.default_command_timeout) {
        var event, event_uuid, p, q, res;
        if (app_arg == null) {
          app_arg = '';
        }
        event_uuid = UUID.v4();
        event = `CHANNEL_EXECUTE_COMPLETE ${event_uuid}`;
        // The Promise is only fulfilled when the command has completed.
        p = this.onceAsync(event, timeout, `uuid ${uuid} ${app_name} ${app_arg}`);
        q = this.execute_uuid(uuid, app_name, app_arg, null, event_uuid);
        [res] = (await Promise.all([p, q]));
        return res;
      }

      // hangup_uuid
      // -----------

      // Hangup the call referenced by the given UUID with an optional (FreeSwitch) cause code.
      hangup_uuid(uuid, hangup_cause) {
        var options;
        if (hangup_cause == null) {
          hangup_cause = 'NORMAL_UNSPECIFIED';
        }
        options = {
          'hangup-cause': hangup_cause
        };
        return this.sendmsg_uuid(uuid, 'hangup', options);
      }

      // unicast_uuid
      // ------------

      // Forwards the media to and from a given socket.

      // Arguments:
      // - `local-ip`
      // - `local-port`
      // - `remote-ip`
      // - `remote-port`
      // - `transport` (`tcp` or `udp`)
      // - `flags: "native"` (optional: do not transcode to/from L16 audio)
      unicast_uuid(uuid, args) {
        return this.sendmsg_uuid(uuid, 'unicast', args);
      }

      // nomedia_uuid
      // ------------

      // Not implemented yet (TODO).

      // Server-mode commands
      // ====================

      // In server (outbound) mode, the target UUID is always our (own) call UUID, so it does not need to be specified.

      // execute
      // -------

      // Execute an application for the current UUID (in server/outbound mode)
      execute(app_name, app_arg) {
        return this.execute_uuid(null, app_name, app_arg);
      }

      // command
      // -------
      command(app_name, app_arg) {
        return this.command_uuid(null, app_name, app_arg);
      }

      // hangup
      // ------
      hangup(hangup_cause) {
        return this.hangup_uuid(null, hangup_cause);
      }

      // unicast
      // -------
      unicast(args) {
        return this.unicast_uuid(null, args);
      }

      // TODO: `nomedia`

      // Cleanup at end of call
      // ======================

      // auto_cleanup
      // ------------

      // Clean-up at the end of the connection.
      // Automatically called by the client and server.
      auto_cleanup() {
        var linger_delay, once_freeswitch_disconnect, once_freeswitch_linger;
        this.once('freeswitch_disconnect_notice', function(res) {
          trace('auto_cleanup: Received ESL disconnection notice', this.__ref, res);
          switch (res.headers['Content-Disposition']) {
            case 'linger':
              trace('Sending freeswitch_linger', this.__ref);
              this.emit('freeswitch_linger');
              break;
            case 'disconnect':
              trace('Sending freeswitch_disconnect', this.__ref);
              this.emit('freeswitch_disconnect'); // Header might be absent?
              break;
            default:
              trace('Sending freeswitch_disconnect', this.__ref);
              this.emit('freeswitch_disconnect');
          }
        });
        // ### Linger

        // In linger mode you may intercept the event `cleanup_linger` to do further processing. However you are responsible for calling `exit()`. If you do not do it, the calls will leak. (Make sure you also `catch` any errors on exit: `exit().catch(...)`.)

        // The default behavior in linger mode is to disconnect the socket after 4 seconds, giving you some time to capture events.
        linger_delay = 4000;
        this.once('freeswitch_linger', once_freeswitch_linger = function() {
          trace('auto_cleanup/linger', this.__ref);
          if (this.emit('cleanup_linger')) {
            debug('auto_cleanup/linger: cleanup_linger processed, make sure you call exit()', this.__ref);
          } else {
            trace(`auto_cleanup/linger: exit() in ${linger_delay}ms`, this.__ref);
            setTimeout(() => {
              trace('auto_cleanup/linger: exit()', this.__ref);
              this.exit().catch(function() {
                return true;
              });
            }, linger_delay);
          }
        });
        // ### Disconnect

        // On disconnect (no linger) mode, you may intercept the event `cleanup_disconnect` to do further processing. However you are responsible for calling `end()` in order to close the socket.

        // Normal behavior on disconnect is to close the socket with `end()`.
        this.once('freeswitch_disconnect', once_freeswitch_disconnect = function() {
          trace('auto_cleanup/disconnect', this.__ref);
          if (this.emit('cleanup_disconnect', this)) {
            debug('auto_cleanup/disconnect: cleanup_disconnect processed, make sure you call end()', this.__ref);
          } else {
            setTimeout(() => {
              trace('auto_cleanup/disconnect: end()', this.__ref);
              return this.end();
            }, 100);
          }
        });
        return null;
      }

    };

    // Event Emitter
    // =============

    // `default_event_timeout`
    // -----------------------

    // The default timeout waiting for events.

    // Note that this value must be longer than (for exemple) a regular call's duration, if you want to be able to catch `EXECUTE_COMPLETE` on `bridge` commands.
    FreeSwitchResponse.prototype.default_event_timeout = 9 * 3600 * 1000; // 9 hours

    FreeSwitchResponse.prototype.command_timeout = 10 * 1000; // 10s

    return FreeSwitchResponse;

  }).call(this);

  // Toolbox
  // =======
  assert = require('assert');

  debug = (require('debug'))('esl:response');

  trace = (require('debug'))('esl:response:trace');

}).call(this);
