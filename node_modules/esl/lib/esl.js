// Generated by CoffeeScript 2.4.1
(function() {
  // Connection Listener (socket events handler)
  // ===========================================

  // We use the same connection-listener for both client (FreeSwitch "inbound" socket) and server (FreeSwitch "outound" socket).
  // This is modelled after Node.js' http.js; the connection-listener is called either when FreeSwitch connects to our server, or when we connect to FreeSwitch from our client.
  var EventEmitter2, FreeSwitchClient, FreeSwitchParser, FreeSwitchParserError, FreeSwitchResponse, FreeSwitchServer, Wrapper, assert, connectionListener, debug, i, len, name, net, parse_header_text, pkg, ref, trace;

  FreeSwitchParserError = class FreeSwitchParserError extends Error {
    constructor(args) {
      super(JSON.stringify(args));
      this.args = args;
      return;
    }

  };

  connectionListener = function(call) {
    var parser;
    // The module provides statistics in the `stats` object if it is initialized. You may use it  to collect your own call-related statistics.

    // The parser will be the one receiving the actual data from the socket. We will process the parser's output below.
    parser = new FreeSwitchParser(call.socket);
    // Make the command responses somewhat unique. This is required since FreeSwitch doesn't provide us a way to match responses with requests.
    call.on('CHANNEL_EXECUTE_COMPLETE', function(res) {
      var event_uuid;
      event_uuid = res.body['Application-UUID'];
      return call.emit(`CHANNEL_EXECUTE_COMPLETE ${event_uuid}`, res);
    });
    call.on('BACKGROUND_JOB', function(res) {
      var job_uuid;
      job_uuid = res.body['Job-UUID'];
      return call.emit_later(`BACKGROUND_JOB ${job_uuid}`, {
        body: res.body._body
      });
    });
    // The parser is responsible for de-framing messages coming from FreeSwitch and splitting it into headers and a body.
    // We then process those in order to generate higher-level events.
    parser.process = function(headers, body) {
      var base, base1, base10, base2, base3, base4, base5, base6, base7, base8, base9, content_type, event, exception, i, len, msg, n, ref;
      // Rewrite headers as needed to work around some weirdnesses in the protocol; and assign unified event IDs to the Event Socket's Content-Types.
      content_type = headers['Content-Type'];
      if (content_type == null) {
        if (call.stats != null) {
          if ((base = call.stats).missing_content_type == null) {
            base.missing_content_type = 0;
          }
          call.stats.missing_content_type++;
        }
        call.emit('error.missing-content-type', new FreeSwitchParserError({headers, body}));
        return;
      }
      // Notice how all our (internal) event names are lower-cased; FreeSwitch always uses full-upper-case event names.
      switch (content_type) {
        // auth/request
        // ------------

        // FreeSwitch sends an authentication request when a client connect to the Event Socket.
        // Normally caught by the client code, there is no need for your code to monitor this event.
        case 'auth/request':
          event = 'freeswitch_auth_request';
          if (call.stats != null) {
            if ((base1 = call.stats).auth_request == null) {
              base1.auth_request = 0;
            }
            call.stats.auth_request++;
          }
          break;
        // command/reply
        // -------------

        // Commands trigger this type of event when they are submitted.
        // Normally caught by `send`, there is no need for your code to monitor this event.
        case 'command/reply':
          event = 'freeswitch_command_reply';
          // Apparently a bug in the response to `connect` causes FreeSwitch to send the headers in the body.
          if (headers['Event-Name'] === 'CHANNEL_DATA') {
            body = headers;
            headers = {};
            ref = ['Content-Type', 'Reply-Text', 'Socket-Mode', 'Control'];
            for (i = 0, len = ref.length; i < len; i++) {
              n = ref[i];
              headers[n] = body[n];
              delete body[n];
            }
          }
          if (call.stats != null) {
            if ((base2 = call.stats).command_reply == null) {
              base2.command_reply = 0;
            }
            call.stats.command_reply++;
          }
          break;
        // text/event-json
        // ---------------

        // A generic event with a JSON body. We map it to its own Event-Name.
        case 'text/event-json':
          if (call.stats != null) {
            if ((base3 = call.stats).events == null) {
              base3.events = 0;
            }
            call.stats.events++;
          }
          try {
            // Strip control characters that might be emitted by FreeSwitch.
            body = body.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            // Parse the JSON body.
            body = JSON.parse(body);
          } catch (error1) {
            // In case of error report it as an error.
            exception = error1;
            trace('Invalid JSON', body);
            if (call.stats != null) {
              if ((base4 = call.stats).json_parse_errors == null) {
                base4.json_parse_errors = 0;
              }
              call.stats.json_parse_errors++;
            }
            call.emit('error.invalid-json', exception);
            return;
          }
          // Otherwise trigger the proper event.
          event = body['Event-Name'];
          break;
        // text/event-plain
        // ----------------

        // Same as `text/event-json` except the body is encoded using plain text. Either way the module provides you with a parsed body (a hash/Object).
        case 'text/event-plain':
          body = parse_header_text(body);
          event = body['Event-Name'];
          if (call.stats != null) {
            if ((base5 = call.stats).events == null) {
              base5.events = 0;
            }
            call.stats.events++;
          }
          break;
        // log/data
        // --------
        case 'log/data':
          event = 'freeswitch_log_data';
          if (call.stats != null) {
            if ((base6 = call.stats).log_data == null) {
              base6.log_data = 0;
            }
            call.stats.log_data++;
          }
          break;
        // text/disconnect-notice
        // ----------------------

        // FreeSwitch's indication that it is disconnecting the socket.
        // You normally do not have to monitor this event; the `autocleanup` methods catches this event and emits either `freeswitch_disconnect` or `freeswitch_linger`, monitor those events instead.
        case 'text/disconnect-notice':
          event = 'freeswitch_disconnect_notice';
          if (call.stats != null) {
            if ((base7 = call.stats).disconnect == null) {
              base7.disconnect = 0;
            }
            call.stats.disconnect++;
          }
          break;
        // api/response
        // ------------

        // Triggered when an `api` message returns. Due to the inability to map those responses to requests, you might want to use `queue_api` instead of `api` for concurrent usage.
        // You normally do not have to monitor this event, the `api` methods catches it.
        case 'api/response':
          event = 'freeswitch_api_response';
          if (call.stats != null) {
            if ((base8 = call.stats).api_responses == null) {
              base8.api_responses = 0;
            }
            call.stats.api_responses++;
          }
          break;
        case 'text/rude-rejection':
          event = 'freeswitch_rude_rejection';
          if (call.stats != null) {
            if ((base9 = call.stats).rude_rejections == null) {
              base9.rude_rejections = 0;
            }
            call.stats.rude_rejections++;
          }
          break;
        default:
          // Ideally other content-types should be individually specified. In any case we provide a fallback mechanism.
          // Others?
          // -------
          trace('Unhandled Content-Type', content_type);
          event = `freeswitch_${content_type.replace(/[^a-z]/, '_')}`;
          call.emit('error.unhandled-content-type', new FreeSwitchParserError({content_type}));
          if (call.stats != null) {
            if ((base10 = call.stats).unhandled == null) {
              base10.unhandled = 0;
            }
            call.stats.unhandled++;
          }
      }
      // Event content
      // -------------

      // The messages sent at the server- or client-level only contain the headers and the body, possibly modified by the above code.
      msg = {headers, body};
      call.emit(event, msg);
    };
    // Get things started
    // ------------------

    // Get things started: notify the application that the connection is established and that we are ready to send commands to FreeSwitch.
    call.emit('freeswitch_connect');
  };

  // Server
  // ======

  // The server is used when FreeSwitch needs to be able to initiate a connection to us so that we can handle an existing call.

  // We inherit from the `Server` class of Node.js' `net` module. This way any method from `Server` may be re-used (although in most cases only `listen` is used).
  net = require('net');

  FreeSwitchServer = class FreeSwitchServer extends net.Server {
    constructor(report, requestListener) {
      super();
      this.on('connection', function(socket) {
        var call;
        // For every new connection to our server we get a new `Socket` object, which we wrap inside our `FreeSwitchResponse` object. This becomes the `call` object used throughout the application.
        call = new FreeSwitchResponse(socket);
        // The `freeswitch_connect` event is triggered by our `connectionListener` once the parser is set up and ready.
        call.once('freeswitch_connect', async function() {
          var exception;
          try {
            // The request-listener is called within the context of the `FreeSwitchResponse` object.
            return (await requestListener.call(call));
          } catch (error1) {
            // All errors are reported on `FreeSwitchResponse`.
            exception = error1;
            return report(exception);
          }
        });
        // The connection-listener is called last to set the parser up and trigger the request-listener.
        connectionListener(call);
      });
      return;
    }

  };

  // The `server` we export is only slightly more complex. It sets up a filter so that the application only gets its own events, and sets up automatic cleanup which will be used before disconnecting the socket.
  // The call handler will receive a `FreeSwitchResponse` object, `options` are optional (and currently unused).
  exports.server = function(options = {}, handler, report) {
    var server;
    if (typeof options === 'function') {
      [options, handler, report] = [{}, options, handler];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug(`Server: ${error}`);
      };
    }
    if (options.all_events == null) {
      options.all_events = true;
    }
    if (options.my_events == null) {
      options.my_events = true;
    }
    assert.ok(handler != null, "server handler is required");
    assert.strictEqual(typeof handler, 'function', "server handler must be a function");
    server = new FreeSwitchServer(report, async function(...args) {
      var Unique_ID, exception, res;
      try {
        // Here starts our default request-listener.
        Unique_ID = 'Unique-ID';
        // Confirm connection with FreeSwitch.
        res = (await this.connect());
        this.data = res.body;
        this.uuid = this.data[Unique_ID];
        if (options.my_events) {
          // Restricting events using `filter` is required so that `event_json` will only obtain our events.
          await this.filter(Unique_ID, this.uuid);
        }
        await this.auto_cleanup();
        if (options.all_events) {
          await this.event_json('ALL');
        } else {
          await this.event_json('CHANNEL_EXECUTE_COMPLETE', 'BACKGROUND_JOB');
        }
        await handler.apply(this, args);
      } catch (error1) {
        exception = error1;
        report(exception);
      }
    });
    debug(`Ready to start ${pkg.name} ${pkg.version} server.`);
    return server;
  };

  // Client
  // ======

  // Client mode is used to place new calls or take over existing calls.

  // We inherit from the `Socket` class of Node.js' `net` module. This way any method from `Socket` may be re-used (although in most cases only `connect` is used).
  FreeSwitchClient = class FreeSwitchClient extends net.Socket {
    constructor() {
      var call;
      super();
      // Contrarily to the server which will handle multiple socket connections over its lifetime, a client only handles one socket, so only one `FreeSwitchResponse` object is needed as well.
      this.call = call = new FreeSwitchResponse(this);
      // Parsing of incoming messages is handled by the connection-listener.
      this.once('connect', function() {
        return connectionListener(call);
      });
      return;
    }

  };

  // The `client` function we provide wraps `FreeSwitchClient` in order to provide some defaults.
  // The `handler` will be called in the context of the `FreeSwitchResponse`; the `options` are optional, but may include a `password`.
  exports.default_password = 'ClueCon';

  exports.client = function(options = {}, handler, report) {
    var client, connectionHandler;
    if (typeof options === 'function') {
      [options, handler, report] = [{}, options, handler];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug(`Client report error: ${error}`);
      };
    }
    // If neither `options` not `password` is provided, the default password is assumed.
    if (options.password == null) {
      options.password = exports.default_password;
    }
    assert.ok(handler != null, "client handler is required");
    assert.strictEqual(typeof handler, 'function', "client handler must be a function");
    client = new FreeSwitchClient();
    // Normally when the client connects, FreeSwitch will first send us an authentication request. We use it to trigger the remainder of the stack.
    connectionHandler = async function() {
      var error;
      try {
        await this.onceAsync('freeswitch_auth_request');
        await this.auth(options.password);
        await this.auto_cleanup();
        await this.event_json('CHANNEL_EXECUTE_COMPLETE', 'BACKGROUND_JOB');
        return (await handler.call(this));
      } catch (error1) {
        error = error1;
        return report(error);
      }
    };
    connectionHandler.call(client.call);
    return client;
  };

  exports.reconnect = function(connect_options, options, handler, report) {
    var client, notify, reconnect, running;
    if (connect_options == null) {
      connect_options = {
        host: '127.0.0.1',
        port: 8021
      };
    }
    ({notify} = connect_options);
    client = null;
    running = true;
    reconnect = function(retry, attempt = 0) {
      var end;
      if (!running) {
        debug(`reconnect attempt #${attempt}: stopping client to `, connect_options);
        return;
      }
      debug(`reconnect attempt #${attempt} (retry is ${retry}ms): (re)connecting client to `, connect_options);
      if (client != null) {
        client.destroy();
      }
      client = exports.client(options, handler, report);
      client.on('error', function(error) {
        if (retry < 5000) {
          if (error.code === 'ECONNREFUSED') {
            retry = Math.floor((retry * 1200) / 1000);
          }
        }
        debug(`reconnect attempt #${attempt}: client received \`error\` event: ${error.code} — ${error}. (Reconnecting in ${retry}ms.)`);
        if (typeof notify === "function") {
          notify('reconnecting', retry);
        }
        setTimeout((function() {
          return reconnect(retry, attempt + 1);
        }), retry);
      });
      client.on('end', function() {
        debug(`reconnect attempt #${attempt}: client received \`end\` event (remote end sent a FIN packet). (Reconnecting in ${retry}ms.)`);
        if (typeof notify === "function") {
          notify('reconnecting', retry);
        }
        setTimeout((function() {
          return reconnect(retry, attempt + 1);
        }), retry);
      });
      client.on('close', function(had_error) {
        debug(`reconnect attempt #${attempt}: client received \`close\` event (due to error: ${had_error}). (Ignored.)`);
        if (typeof notify === "function") {
          notify('close', had_error);
        }
      });
      (async function() {
        var error;
        try {
          return (await client.connect(connect_options));
        } catch (error1) {
          error = error1;
          return console.error('connect', error);
        }
      })();
      return end = function() {
        debug(`reconnect attempt #${attempt}: end requested by application.`);
        if (typeof notify === "function") {
          notify('end');
        }
        running = false;
        return client != null ? client.end() : void 0;
      };
    };
    return reconnect(200);
  };

  // createClient
  // ============
  ({EventEmitter2} = require('eventemitter2'));

  // Options are socket.connect options plus `password`.
  Wrapper = class Wrapper extends EventEmitter2 {
    constructor(options) {
      var handler, notify, report, self;
      super();
      self = this;
      notify = function(event, ...args) {
        if (event === 'error') {
          if (self.listeners('error').length > 0) {
            self.emit('error', error);
          }
        } else {
          self.emit(event, ...args);
        }
      };
      handler = function() {
        self.client = this;
        return self.emit('connect', this);
      };
      report = function(error) {
        return notify('error', error);
      };
      options.notify = notify;
      this.end = exports.reconnect(options, options, handler, report);
      return;
    }

  };

  ref = 'write send api bgapi event_json nixevent noevents filter filter_delete sendevent auth connect linger exit log nolog\nsengmsg_uuid sendmsg execute_uuid command_uuid hangup_uuid unicast_uuid\nexecute command hangup unicast'.split(/\s+/);
  for (i = 0, len = ref.length; i < len; i++) {
    name = ref[i];
    (function(name) {
      return Wrapper.prototype[name] = function(...args) {
        trace(`Wrapper::${name}`, args);
        return this.client[name](...args);
      };
    })(name);
  }

  exports.createClient = function(options) {
    return new Wrapper(options);
  };

  // Please note that the client is not started with `event_json ALL` since by default this would mean obtaining all events from FreeSwitch. Instead, we only monitor the events we need to be notified for (commands and `bgapi` responses).
  // You must manually run `@event_json` and an optional `@filter` command.

  // Toolbox
  // -------
  assert = require('assert');

  FreeSwitchParser = require('./parser');

  FreeSwitchResponse = require('./response');

  ({parse_header_text} = FreeSwitchParser);

  pkg = require('../package.json');

  debug = (require('debug'))('esl:main');

  trace = (require('debug'))('esl:main:trace');

}).call(this);
